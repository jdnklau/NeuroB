package de.hhu.stups.neurob.training.generation;

import de.hhu.stups.neurob.core.api.backends.Backend;
import de.hhu.stups.neurob.core.api.bmethod.BMachine;
import de.hhu.stups.neurob.core.api.bmethod.BPredicate;
import de.hhu.stups.neurob.core.api.bmethod.MachineAccess;
import de.hhu.stups.neurob.core.exceptions.FormulaException;
import de.hhu.stups.neurob.core.exceptions.LabelCreationException;
import de.hhu.stups.neurob.core.exceptions.FeatureCreationException;
import de.hhu.stups.neurob.core.exceptions.MachineAccessException;
import de.hhu.stups.neurob.core.features.predicates.PredicateFeatureGenerating;
import de.hhu.stups.neurob.core.labelling.Labelling;
import de.hhu.stups.neurob.core.labelling.PredicateLabelGenerating;
import de.hhu.stups.neurob.core.labelling.PredicateLabelling;
import de.hhu.stups.neurob.training.data.TrainingSample;
import de.hhu.stups.neurob.training.db.JsonDbFormat;
import de.hhu.stups.neurob.training.formats.TrainingDataFormat;
import de.hhu.stups.neurob.training.generation.util.FormulaGenerator;
import de.hhu.stups.neurob.training.generation.util.PredicateCollection;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.attribute.FileTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;

public class PredicateTrainingGenerator
        extends TrainingSetGenerator {

    private static Logger log =
            LoggerFactory.getLogger(PredicateFeatureGenerating.class);
    private final int labellingSamples;

    protected List<Function<PredicateCollection, List<BPredicate>>> generationRules;

    private boolean isAstCleanup = false;

    /**
     * Sets up a training set generator. The training set consists of the features generated by
     * the supplied {@link PredicateFeatureGenerating featureGenerator},
     * whereas the labels confirm to the format created by the
     * {@link PredicateLabelGenerating labelGenerator}.
     *
     * The training set is stored in the specified {@link TrainingDataFormat format}.
     *
     * @param featureGenerator
     * @param labelGenerator
     * @param format
     * @param <F>
     * @param <L>
     */
    public <F, L extends PredicateLabelling>
    PredicateTrainingGenerator(
            PredicateFeatureGenerating<F> featureGenerator,
            PredicateLabelGenerating<L> labelGenerator,
            TrainingDataFormat<? super F, ? super L> format) {
        this(featureGenerator, labelGenerator, 1, format);
    }

    /**
     * Sets up a training set generator. The training set consists of the features generated by
     * the supplied {@link PredicateFeatureGenerating featureGenerator},
     * whereas the labels confirm to the format created by the
     * {@link PredicateLabelGenerating labelGenerator}.
     *
     * The amount specified by {@code labellingSamples} dictates how often the labelling will be
     * created for each sample, yielding multiple feature-label pairs.
     * This might be useful for sampling e.g. multiple runtimes.
     *
     * The training set is stored in the specified {@link TrainingDataFormat format}.
     *
     * @param featureGenerator
     * @param labelGenerator
     * @param labellingSamples
     * @param format
     * @param <F>
     * @param <L>
     */
    public <F, L extends PredicateLabelling>
    PredicateTrainingGenerator(
            PredicateFeatureGenerating<F> featureGenerator,
            PredicateLabelGenerating<L> labelGenerator,
            int labellingSamples,
            TrainingDataFormat<? super F, ? super L> format) {
        super(featureGenerator, labelGenerator, format);
        this.labellingSamples = labellingSamples;

        generationRules = new ArrayList<>();
        generationRules.add(FormulaGenerator::assertions);
        generationRules.add(FormulaGenerator::enablingRelationships);
        generationRules.add(FormulaGenerator::invariantPreservations);
        generationRules.add(FormulaGenerator::multiPreconditionFormulae);
        generationRules.add(FormulaGenerator::extendedPreconditionFormulae);

    }

    /**
     * Constructor for creating a data base of predicates.
     */
    public PredicateTrainingGenerator() {
        this(
                (pred, ss) -> pred,
                JsonDbFormat.getLabelGenerator(JsonDbFormat.DEFAULT_BACKENDS),
                1,
                new JsonDbFormat(JsonDbFormat.DEFAULT_BACKENDS)
        );
    }

    /**
     * Constructor for creating a data base of predicates, labelling each one
     * the given amount of times.
     */
    public PredicateTrainingGenerator(int labellingSamples) {
        this(
                (pred, ss) -> pred,
                JsonDbFormat.getLabelGenerator(JsonDbFormat.DEFAULT_BACKENDS),
                labellingSamples,
                new JsonDbFormat(JsonDbFormat.DEFAULT_BACKENDS)
        );
    }

    @Override
    public Stream<TrainingSample> streamSamplesFromFile(Path file) {
        log.info("Loading training samples from {}", file);

        return streamSamplesFromFile(new BMachine(file));
    }

    public Stream<TrainingSample> streamSamplesFromFile(BMachine bMachine) {
        try {
            log.info("Accessing B machine {}", bMachine);
            MachineAccess access = bMachine.spawnMachineAccess();
            Stream<BPredicate> predicates = streamPredicatesFromFile(bMachine);

            // Stream training samples
            Stream<TrainingSample> samples = predicates.flatMap(
                    predicate -> {
                        try {
                            log.trace("Generating sample for {}", predicate);
                            BPredicate p = predicate;
                            if (isAstCleanup) {
                                p = FormulaGenerator.cleanupAst(access, predicate);
                            }
                            return generateSamples(p, access);
                        } catch (FeatureCreationException e) {
                            log.warn("Could not create features from {}", predicate, e);
                        } catch (LabelCreationException e) {
                            log.warn("Could not create labelling for {}", predicate, e);
                        } catch (FormulaException e) {
                            log.warn("Could not cleanup predicate {}", predicate, e);
                        }
                        // If any exceptions occur, return nothing
                        return Stream.empty();
                    })
                    .onClose(access::close);

            return samples.filter(Objects::nonNull)
                    // add source file information
                    .map(sample -> new TrainingSample<>(
                            sample.getData(),
                            sample.getLabelling(),
                            bMachine.getLocation()));

        } catch (MachineAccessException e) {
            log.warn("Unable to access {}", bMachine, e);
            return Stream.empty();
        }
    }

    /**
     * Takes a predicate and generates a pair of Features and Labelling out of
     * it,
     * returning a TrainingSample containing both.
     *
     * @param predicate Predicate to be translated into a training
     *         sample.
     *
     * @return
     *
     * @throws FeatureCreationException
     * @throws LabelCreationException
     */
    public Stream<TrainingSample> generateSamples(BPredicate predicate)
            throws FeatureCreationException, LabelCreationException {
        return generateSamples(predicate, null);
    }

    /**
     * Takes a predicate and generates a pair of Features and Labelling out of
     * it,
     * returning a TrainingSample containing both.
     *
     * @param predicate Predicate to be translated into a training
     *         sample.
     * @param access Access to the machine file the predicate belongs to.
     *
     * @return
     *
     * @throws FeatureCreationException
     * @throws LabelCreationException
     */
    public Stream<TrainingSample> generateSamples(BPredicate predicate, MachineAccess access)
            throws FeatureCreationException, LabelCreationException {
        log.info("Generating features for {}", predicate);

        Object features = ((PredicateFeatureGenerating) featureGenerator)
                .generate(predicate, access);

        log.info("Generating labelling for {}", predicate);
        List<Labelling> labellings = ((PredicateLabelGenerating) labelGenerator)
                .generateSamples(predicate, access, labellingSamples);

        return labellings.stream().map(label -> new TrainingSample<>(features, label));
    }

    @Override
    public boolean dataAlreadyExists(Path sourceFile, Path targetLocation) {
        if (Files.exists(targetLocation, LinkOption.NOFOLLOW_LINKS)) {
            try {
                FileTime sourceLastModified = Files.getLastModifiedTime(
                        sourceFile, LinkOption.NOFOLLOW_LINKS);
                FileTime targetLastModified = Files.getLastModifiedTime(
                        targetLocation, LinkOption.NOFOLLOW_LINKS);

                // last edit source file <= last edit target file -> nothing to do here
                if (sourceLastModified.compareTo(targetLastModified) <= 0) {
                    return format.isValidFile(targetLocation);
                }
            } catch (IOException e) {
                log.warn("Could not determine whether for the source file {} "
                         + "the target location {} is up to date or not. "
                         + "Generating data anyway.",
                        sourceFile, targetLocation, e);
            }
        }
        return false;
    }

    /**
     * Generates predicates from given machine file.
     * The given {@link MachineAccess} belongs to the already loaded machine.
     * If {@code bMachine} is {@code null}, an access will be opened first.
     * <p>
     * The predicates are generated with the following functions:
     * <ul>
     * <p>
     * The stream needs to be closed after use.
     * <li>{@link FormulaGenerator#assertions(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#enablingRelationships(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#invariantPreservations(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#multiPreconditionFormulae(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#extendedPreconditionFormulae(PredicateCollection)}</li>
     * </ul>
     *
     * @param file B machine to access.
     *
     * @return Stream of generated predicates.
     */
    public Stream<BPredicate> streamPredicatesFromFile(Path file) {
        PredicateCollection pc;
        MachineAccess bMachine;
        try {
            bMachine = new MachineAccess(file);
            pc = new PredicateCollection(bMachine);
        } catch (MachineAccessException e) {
            log.warn("Could not load {}; no predicates generated", file, e);
            return Stream.empty();
        }

        return streamPredicatesFromCollection(pc).onClose(bMachine::close);
    }

    /**
     * Generates predicates from given B machine.
     * <p>
     * The predicates are generated with the following functions:
     * <ul>
     * <li>{@link FormulaGenerator#assertions(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#enablingRelationships(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#invariantPreservations(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#multiPreconditionFormulae(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#extendedPreconditionFormulae(PredicateCollection)}</li>
     * </ul>
     * <p>
     * The stream needs to be closed after use.
     *
     * @param bMachine B machine to access.
     *
     * @return Stream of generated predicates.
     */
    public Stream<BPredicate> streamPredicatesFromFile(BMachine bMachine) throws MachineAccessException {
        MachineAccess access = bMachine.spawnMachineAccess();
        PredicateCollection pc = new PredicateCollection(access);
        return streamPredicatesFromCollection(pc)
                .onClose(access::close);
    }

    public void setGenerationRules(Function<PredicateCollection, List<BPredicate>>... rules) {
        this.generationRules = Arrays.asList(rules);
    }

    /**
     * Streams generated predicates from a given {@link PredicateCollection}.
     * <p>
     * The predicates are generated with the following default functions:
     * <ul>
     * <li>{@link FormulaGenerator#assertions(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#enablingRelationships(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#invariantPreservations(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#multiPreconditionFormulae(PredicateCollection)}</li>
     * <li>{@link FormulaGenerator#extendedPreconditionFormulae(PredicateCollection)}</li>
     * </ul>
     *
     * To alter the generation procedure use {@link #setGenerationRules(Function[])}.
     *
     * @param collection
     *
     * @return
     */
    public Stream<BPredicate> streamPredicatesFromCollection(
            PredicateCollection collection) {
        return generationRules.stream()
                .flatMap(gen -> gen.apply(collection).stream());
    }

    public void setAstCleanup(boolean cleanupActive) {
        this.isAstCleanup = cleanupActive;
    }
}

